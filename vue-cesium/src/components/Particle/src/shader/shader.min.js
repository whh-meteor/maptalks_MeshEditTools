!function(){var e={41:function(e){e.exports="#version 300 es\n\n// the size of UV textures: width = lon, height = lat*lev\nuniform sampler2D U; // eastward wind \nuniform sampler2D V; // northward wind\nuniform sampler2D W; // upward wind\nuniform sampler2D currentParticlesPosition; // (lon, lat, lev)\n\nuniform vec3 dimension; // (lon, lat, lev)\nuniform vec3 minimum; // minimum of each dimension\nuniform vec3 maximum; // maximum of each dimension\nuniform vec3 interval; // interval of each dimension\n\n// used to calculate the wind norm\nuniform vec2 uSpeedRange; // (min, max);\nuniform vec2 vSpeedRange;\nuniform vec2 wSpeedRange;\nuniform float speedScaleFactor;\n\nin vec2 v_textureCoordinates;\n\nvec2 mapPositionToNormalizedIndex2D(vec3 lonLatLev) {\n    // ensure the range of longitude and latitude\n    lonLatLev.x = clamp(lonLatLev.x, minimum.x, maximum.x);\n    lonLatLev.y = clamp(lonLatLev.y,  minimum.y, maximum.y);\n    lonLatLev.z = clamp(lonLatLev.z,  minimum.z, maximum.z);\n\n    vec3 index3D = vec3(0.0);\n    index3D.x = (lonLatLev.x - minimum.x) / interval.x;\n    index3D.y = (lonLatLev.y - minimum.y) / interval.y;\n    // map the z-axis value to the nearest bit plane to ensure that the result is an integer\n    index3D.z = ceil((lonLatLev.z - minimum.z) / interval.z); \n\n    // the st texture coordinate corresponding to (col, row) index\n    // example\n    // data array is [0, 1, 2, 3, 4, 5, 7, 8, 9], width = 2, height = 2, level = 2\n    // the content of texture will be\n    // t 1.0\n    //    |  6 7\n    //    |  4 5\n    //    |  2 3\n    //    |  0 1\n    //   0.0------1.0 s\n\n    vec2 index2D = vec2(index3D.x, index3D.z * dimension.y + index3D.y);\n    vec2 normalizedIndex2D = vec2(index2D.x / dimension.x, index2D.y / (dimension.y * dimension.z));\n    return normalizedIndex2D;\n}\n\nfloat getWindComponent(sampler2D componentTexture, vec3 lonLatLev) {\n    vec2 normalizedIndex2D = mapPositionToNormalizedIndex2D(lonLatLev);\n    float result = texture(componentTexture, normalizedIndex2D).r;\n    return result;\n}\n\nfloat interpolateTexture(sampler2D componentTexture, vec3 lonLatLev) {\n    float lon = lonLatLev.x;\n    float lat = lonLatLev.y;\n    float lev = lonLatLev.z;\n\n    float lon0 = floor(lon / interval.x) * interval.x;\n    float lon1 = lon0 + 1.0 * interval.x;\n    float lat0 = floor(lat / interval.y) * interval.y;\n    float lat1 = lat0 + 1.0 * interval.y;\n\n    float lon0_lat0 = getWindComponent(componentTexture, vec3(lon0, lat0, lev));\n    float lon1_lat0 = getWindComponent(componentTexture, vec3(lon1, lat0, lev));\n    float lon0_lat1 = getWindComponent(componentTexture, vec3(lon0, lat1, lev));\n    float lon1_lat1 = getWindComponent(componentTexture, vec3(lon1, lat1, lev));\n\n    float lon_lat0 = mix(lon0_lat0, lon1_lat0, lon - lon0);\n    float lon_lat1 = mix(lon0_lat1, lon1_lat1, lon - lon0);\n    float lon_lat = mix(lon_lat0, lon_lat1, lat - lat0);\n    return lon_lat;\n}\n\nvec3 linearInterpolation(vec3 lonLatLev) {\n    // https://en.wikipedia.org/wiki/Bilinear_interpolation\n    float u = interpolateTexture(U, lonLatLev);\n    float v = interpolateTexture(V, lonLatLev);\n    float w = interpolateTexture(W, lonLatLev);\n    return vec3(u, v, w);\n}\n\nvec2 lengthOfLonLat(vec3 lonLatLev) {\n    // unit conversion: meters -> longitude latitude degrees\n    // see https://en.wikipedia.org/wiki/Geographic_coordinate_system#Length_of_a_degree for detail\n\n    // Calculate the length of a degree of latitude and longitude in meters\n    float latitude = radians(lonLatLev.y);\n\n    float term1 = 111132.92;\n    float term2 = 559.82 * cos(2.0 * latitude);\n    float term3 = 1.175 * cos(4.0 * latitude);\n    float term4 = 0.0023 * cos(6.0 * latitude);\n    float latLength = term1 - term2 + term3 - term4;\n\n    float term5 = 111412.84 * cos(latitude);\n    float term6 = 93.5 * cos(3.0 * latitude);\n    float term7 = 0.118 * cos(5.0 * latitude);\n    float longLength = term5 - term6 + term7;\n\n    return vec2(longLength, latLength);\n}\n\nvec3 convertSpeedUnitToLonLat(vec3 lonLatLev, vec3 speed) {\n    vec2 lonLatLength = lengthOfLonLat(lonLatLev);\n    float u = speed.x / lonLatLength.x;\n    float v = speed.y / lonLatLength.y;\n    float w = speed.z;\n    vec3 windVectorInLonLatLev = vec3(u, v, w);\n\n    return windVectorInLonLatLev;\n}\n\nvec3 calculateSpeedByRungeKutta2(vec3 lonLatLev) {\n    // see https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods#Second-order_methods_with_two_stages for detail\n    const float h = 0.5;\n\n    vec3 y_n = lonLatLev;\n    vec3 f_n = linearInterpolation(lonLatLev);\n    vec3 midpoint = y_n + 0.5 * h * convertSpeedUnitToLonLat(y_n, f_n) * speedScaleFactor;\n    vec3 speed = h * linearInterpolation(midpoint) * speedScaleFactor;\n\n    return speed;\n}\n\nvec2 getRange(vec2 range) {\n  float x1 = 0.0 - range.x;\n  float x2 = range.y - 0.0;\n  if(x1 < 0.0 || x2 < 0.0){\n    return vec2(abs(x1), abs(x2));\n  } else {\n    return vec2(0.0, abs(max(x1, x2)));\n  }\n}\n\nfloat calculateWindNorm(vec3 speed) {\n    vec3 percent = vec3(0.0);\n    vec2 uRange = getRange(uSpeedRange);\n    vec2 vRange = getRange(vSpeedRange);\n    vec2 wRange = getRange(wSpeedRange);\n    if(length(speed.xyz) == 0.0){\n      return 0.0;\n    }\n\n    percent.x = (abs(speed.x) - uRange.x) / (uRange.y - uRange.x);\n    percent.y = (abs(speed.y) - vRange.x) / (vRange.y - vRange.x);\n    if(wSpeedRange.y == wSpeedRange.x){\n      percent.z = 0.0;\n    } else {\n      percent.z = (abs(speed.z) - wRange.x) / (wRange.y - wRange.x);\n    }\n    float norm = length(percent);\n\n    return norm;\n}\n\nout vec4 fragColor;\n\nvoid main() {\n    // texture coordinate must be normalized\n    vec3 lonLatLev = texture(currentParticlesPosition, v_textureCoordinates).rgb;\n    vec3 speedOrigin = linearInterpolation(lonLatLev);\n    vec3 speed = calculateSpeedByRungeKutta2(lonLatLev);\n    vec3 speedInLonLat = convertSpeedUnitToLonLat(lonLatLev, speed);\n\n    vec4 particleSpeed = vec4(speedInLonLat, calculateWindNorm(speed / speedScaleFactor));\n    // gl_FragColor = particleSpeed;\n    fragColor = vec4(speedInLonLat, calculateWindNorm(speedOrigin));\n}\n"},650:function(e){e.exports="#version 300 es\n\nin vec3 position;\nin vec2 st;\n\nout vec2 textureCoordinate;\n\nvoid main() {\n    textureCoordinate = st;\n    gl_Position = vec4(position, 1.0);\n}\n"},391:function(e){e.exports="#version 300 es\nprecision highp float;\n\nuniform sampler2D nextParticlesPosition;\nuniform sampler2D particlesSpeed; // (u, v, w, norm)\n\nuniform sampler2D H; // particles height textures\n\nuniform vec3 dimension; // (lon, lat, lev)\nuniform vec3 minimum; // minimum of each dimension\nuniform vec3 maximum; // maximum of each dimension\nuniform vec3 interval; // interval of each dimension\n\n// range (min, max)\nuniform vec2 lonRange;\nuniform vec2 latRange;\nuniform vec2 viewerLonRange;\nuniform vec2 viewerLatRange;\n\nconst float randomCoefficient = 0.1; // use to improve the pseudo-random generator\nconst float dropRate = 0.1; // drop rate is a chance a particle will restart at random position to avoid degeneration\nconst float dropRateBump = 0.1;\n\nin vec2 v_textureCoordinates;\n\nvec2 mapPositionToNormalizedIndex2D(vec3 lonLatLev) {\n    // ensure the range of longitude and latitude\n    lonLatLev.x = clamp(lonLatLev.x, minimum.x, maximum.x);\n    lonLatLev.y = clamp(lonLatLev.y,  minimum.y, maximum.y);\n    lonLatLev.z = clamp(lonLatLev.z,  minimum.z, maximum.z);\n\n    vec3 index3D = vec3(0.0);\n    index3D.x = (lonLatLev.x - minimum.x) / interval.x;\n    index3D.y = (lonLatLev.y - minimum.y) / interval.y;\n    index3D.z = ceil((lonLatLev.z - minimum.z) / interval.z); \n\n    vec2 index2D = vec2(index3D.x, index3D.z * dimension.y + index3D.y);\n    vec2 normalizedIndex2D = vec2(index2D.x / dimension.x, index2D.y / (dimension.y * dimension.z));\n    return normalizedIndex2D;\n}\n\nvec4 getTextureValue(sampler2D componentTexture, vec3 lonLatLev) {\n    vec2 normalizedIndex2D = mapPositionToNormalizedIndex2D(lonLatLev);\n    vec4 result = texture(componentTexture, normalizedIndex2D);\n    return result;\n}\n\n// pseudo-random generator\nconst vec3 randomConstants = vec3(12.9898, 78.233, 4375.85453);\nconst vec2 normalRange = vec2(0.0, 1.0);\nfloat rand(vec2 seed, vec2 range) {\n    vec2 randomSeed = randomCoefficient * seed;\n    float temp = dot(randomConstants.xy, randomSeed);\n    temp = fract(sin(temp) * (randomConstants.z + temp));\n    return temp * (range.y - range.x) + range.x;\n}\n\nbool particleNoSpeed(vec3 particle) {\n    vec4 speed = getTextureValue(particlesSpeed, particle);\n    return speed.r == 0.0 && speed.g == 0.0;\n}\n\nvec3 generateRandomParticle(vec2 seed, float lev) {\n    // ensure the longitude is in [0, 360]\n    float randomLon = mod(rand(seed, lonRange), 360.0);\n    float randomLat = rand(-seed, latRange);\n    \n    float height = getTextureValue(H, vec3(randomLon, randomLat, lev)).r;\n\n    return vec3(randomLon, randomLat, height);\n}\n\nbool particleOutbound(vec3 particle) {\n    return particle.y < viewerLatRange.x || particle.y > viewerLatRange.y || particle.x < viewerLonRange.x || particle.x > viewerLonRange.y;\n}\n\nout vec4 fragColor;\n\nvoid main() {\n    vec3 nextParticle = texture(nextParticlesPosition, v_textureCoordinates).rgb;\n    vec4 nextSpeed = texture(particlesSpeed, v_textureCoordinates);\n    float speedNorm = nextSpeed.a;\n    float particleDropRate = dropRate + dropRateBump * speedNorm;\n\n    vec2 seed1 = nextParticle.xy + v_textureCoordinates;\n    vec2 seed2 = nextSpeed.xy + v_textureCoordinates;\n    vec3 randomParticle = generateRandomParticle(seed1, nextParticle.z);\n    float randomNumber = rand(seed2, normalRange);\n\n    if (randomNumber < particleDropRate || particleOutbound(nextParticle)) {\n        fragColor = vec4(randomParticle, 1.0); // 1.0 means this is a random particle\n    } else {\n        fragColor = vec4(nextParticle, 0.0);\n    }\n}\n"},165:function(e){e.exports="#version 300 es\n\nuniform sampler2D trailsColorTexture;\nuniform sampler2D trailsDepthTexture;\n\nin vec2 textureCoordinate;\nout vec4 fragColor;\n\nvoid main() {\n    vec4 trailsColor = texture(trailsColorTexture, textureCoordinate);\n    float trailsDepth = texture(trailsDepthTexture, textureCoordinate).r;\n    float globeDepth = czm_unpackDepth(texture(czm_globeDepthTexture, textureCoordinate));\n\n    if (trailsDepth < globeDepth) {\n        fragColor = trailsColor;\n    } else {\n        fragColor = vec4(0.0);\n    }\n}"},918:function(e){e.exports="#version 300 es\n\nuniform sampler2D colorTable;\nuniform bool colour;\n\nin float heightNormalization;\nin float speedNormalization;\n\nout vec4 fragColor;\n\nvoid main() {\n  const float zero = 0.0;\n  if(speedNormalization > zero){\n    if(colour){\n      fragColor = texture(colorTable, vec2(heightNormalization, zero));\n    } else {\n      fragColor = texture(colorTable, vec2(speedNormalization, zero));\n    }\n  } else {\n    fragColor = vec4(zero);\n  }\n}\n"},473:function(e){e.exports="#version 300 es\nprecision highp float;\n\nin vec2 st;\n// it is not normal itself, but used to control lines drawing\nin vec3 normal; // (point to use, offset sign, not used component)\nuniform vec2 hRange;\nuniform vec2 uSpeedRange; // (min, max);\nuniform vec2 vSpeedRange;\nuniform vec2 wSpeedRange;\n\nuniform sampler2D previousParticlesPosition;\nuniform sampler2D currentParticlesPosition;\nuniform sampler2D postProcessingPosition;\nuniform sampler2D particlesSpeed;\n\nuniform float particleHeight;\n\nuniform float aspect;\nuniform float pixelSize;\nuniform float lineWidth;\n\nstruct adjacentPoints {\n    vec4 previous;\n    vec4 current;\n    vec4 next;\n};\n\nout float heightNormalization;\nout float speedNormalization;\nvec3 convertCoordinate(vec3 lonLatLev) {\n    // WGS84 (lon, lat, lev) -> ECEF (x, y, z)\n    // read https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates for detail\n\n    // WGS 84 geometric constants \n    float a = 6378137.0; // Semi-major axis \n    float b = 6356752.3142; // Semi-minor axis \n    float e2 = 6.69437999014e-3; // First eccentricity squared\n\n    float latitude = radians(lonLatLev.y);\n    float longitude = radians(lonLatLev.x);\n\n    float cosLat = cos(latitude);\n    float sinLat = sin(latitude);\n    float cosLon = cos(longitude);\n    float sinLon = sin(longitude);\n\n    float N_Phi = a / sqrt(1.0 - e2 * sinLat * sinLat);\n    float h = particleHeight + lonLatLev.z; // it should be high enough otherwise the particle may not pass the terrain depth test\n    vec3 cartesian = vec3(0.0);\n    cartesian.x = (N_Phi + h) * cosLat * cosLon;\n    cartesian.y = (N_Phi + h) * cosLat * sinLon;\n    cartesian.z = ((b * b) / (a * a) * N_Phi + h) * sinLat;\n    return cartesian;\n}\n\nvec4 calculateProjectedCoordinate(vec3 lonLatLev) {\n    // the range of longitude in Cesium is [-180, 180] but the range of longitude in the NetCDF file is [0, 360]\n    // [0, 180] is corresponding to [0, 180] and [180, 360] is corresponding to [-180, 0]\n    lonLatLev.x = mod(lonLatLev.x + 180.0, 360.0) - 180.0;\n    vec3 particlePosition = convertCoordinate(lonLatLev);\n    vec4 projectedCoordinate = czm_modelViewProjection * vec4(particlePosition, 1.0);\n    return projectedCoordinate;\n}\n\nvec4 calculateOffsetOnNormalDirection(vec4 pointA, vec4 pointB, float offsetSign) {\n    vec2 aspectVec2 = vec2(aspect, 1.0);\n    vec2 pointA_XY = (pointA.xy / pointA.w) * aspectVec2;\n    vec2 pointB_XY = (pointB.xy / pointB.w) * aspectVec2;\n\n    float offsetLength = lineWidth / 2.0;\n    vec2 direction = normalize(pointB_XY - pointA_XY);\n    vec2 normalVector = vec2(-direction.y, direction.x);\n    normalVector.x = normalVector.x / aspect;\n    normalVector = offsetLength * normalVector;\n\n    vec4 offset = vec4(offsetSign * normalVector, 0.0, 0.0);\n    return offset;\n}\n\nfloat calculateWindNorm(vec3 speed) {\n    vec3 percent = vec3(0.0);\n    percent.x = (speed.x - uSpeedRange.x) / (uSpeedRange.y - uSpeedRange.x);\n    percent.y = (speed.y - vSpeedRange.x) / (vSpeedRange.y - vSpeedRange.x);\n    if(wSpeedRange.y == wSpeedRange.x){\n      percent.z = 0.0;\n    } else {\n      percent.z = (speed.z - wSpeedRange.x) / (wSpeedRange.y - wSpeedRange.x);\n    }\n    float norm = length(percent);\n\n    return norm;\n}\n\nvoid main() {\n    vec2 particleIndex = st;\n\n    vec3 previousPosition = texture(previousParticlesPosition, particleIndex).rgb;\n    vec3 currentPosition = texture(currentParticlesPosition, particleIndex).rgb;\n    vec3 nextPosition = texture(postProcessingPosition, particleIndex).rgb;\n\n    float isAnyRandomPointUsed = texture(postProcessingPosition, particleIndex).a +\n        texture(currentParticlesPosition, particleIndex).a +\n        texture(previousParticlesPosition, particleIndex).a;\n\n    adjacentPoints projectedCoordinates;\n    if (isAnyRandomPointUsed > 0.0) {\n        projectedCoordinates.previous = calculateProjectedCoordinate(previousPosition);\n        projectedCoordinates.current = projectedCoordinates.previous;\n        projectedCoordinates.next = projectedCoordinates.previous;\n    } else {\n        projectedCoordinates.previous = calculateProjectedCoordinate(previousPosition);\n        projectedCoordinates.current = calculateProjectedCoordinate(currentPosition);\n        projectedCoordinates.next = calculateProjectedCoordinate(nextPosition);\n    }\n\n    int pointToUse = int(normal.x);\n    float offsetSign = normal.y;\n    vec4 offset = vec4(0.0);\n    // render lines with triangles and miter joint\n    // read https://blog.scottlogic.com/2019/11/18/drawing-lines-with-webgl.html for detail\n    if (pointToUse == -1) {\n        offset = pixelSize * calculateOffsetOnNormalDirection(projectedCoordinates.previous, projectedCoordinates.current, offsetSign);\n        gl_Position = projectedCoordinates.previous + offset;\n    } else  if (pointToUse == 1) {\n        offset = pixelSize * calculateOffsetOnNormalDirection(projectedCoordinates.current, projectedCoordinates.next, offsetSign);\n        gl_Position = projectedCoordinates.next + offset;\n    }\n\n    heightNormalization = (currentPosition.z - hRange.x) / (hRange.y - hRange.x);\n    \n    speedNormalization = texture(particlesSpeed, particleIndex).a;\n}\n"},193:function(e){e.exports="#version 300 es\n\nprecision highp float;\n\nin vec2 textureCoordinate;\n\nuniform sampler2D segmentsColorTexture;\nuniform sampler2D segmentsDepthTexture;\n\nuniform sampler2D currentTrailsColor;\nuniform sampler2D trailsDepthTexture;\n\nuniform float fadeOpacity;\n\nout vec4 fragColor;\nvoid main() {\n    vec4 pointsColor = texture(segmentsColorTexture, textureCoordinate);\n    vec4 trailsColor = texture(currentTrailsColor, textureCoordinate);\n    trailsColor = floor(fadeOpacity * 255.0 * trailsColor) / 255.0; // make sure the trailsColor will be strictly decreased\n\n    float pointsDepth = texture(segmentsDepthTexture, textureCoordinate).r;\n    float trailsDepth = texture(trailsDepthTexture, textureCoordinate).r;\n    float globeDepth = czm_unpackDepth(texture(czm_globeDepthTexture, textureCoordinate));\n    fragColor = vec4(0.0);\n    if (pointsDepth < globeDepth) {\n        fragColor = fragColor + pointsColor;\n    }\n    if (trailsDepth < globeDepth) {\n        fragColor = fragColor + trailsColor;\n    }\n    gl_FragDepth = min(pointsDepth, trailsDepth);\n}\n"},814:function(e){e.exports="#version 300 es\n\nprecision highp float;\n\nuniform sampler2D currentParticlesPosition; // (lon, lat, lev)\nuniform sampler2D particlesSpeed; // (u, v, w, norm) Unit converted to degrees of longitude and latitude \n\nin vec2 v_textureCoordinates;\n\nout vec4 fragColor;\n\nvoid main() {\n    // texture coordinate must be normalized\n    vec3 lonLatLev = texture(currentParticlesPosition, v_textureCoordinates).rgb;\n    vec3 speed = texture(particlesSpeed, v_textureCoordinates).rgb;\n    vec3 nextParticle = lonLatLev + speed;\n    if(length(speed.rgb) > 0.0) {\n      fragColor = vec4(nextParticle, 0.0);\n    } else {\n      fragColor = vec4(0.0);\n    }\n}"}},n={};function t(o){var r=n[o];if(void 0!==r)return r.exports;var a=n[o]={exports:{}};return e[o](a,a.exports,t),a.exports}t.d=function(e,n){for(var o in n)t.o(n,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};!function(){"use strict";t.r(o),t.d(o,{CalculateSpeedShader:function(){return e},PostProcessingPositionShader:function(){return r},UpdatePositionShader:function(){return n},fullscreenVert:function(){return i},screenDrawFrag:function(){return l},segmentDrawFrag:function(){return c},segmentDrawVert:function(){return a},trailDrawFrag:function(){return s}});var e=t(41),n=t(814),r=t(391),a=t(473),i=t(650),l=t(165),c=t(918),s=t(193)}();var r=exports;for(var a in o)r[a]=o[a];o.__esModule&&Object.defineProperty(r,"__esModule",{value:!0})}();